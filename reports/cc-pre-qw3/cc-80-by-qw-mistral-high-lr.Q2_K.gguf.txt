 694 51 ==> ( 31744/6.1%): [+] 20043 (0.6) 799s
 819 68 ==> (313344/8.0%): [ ] 250001 (0.8) 10155s
1977 63 ==> (31076136/0.0%)
1794 73 ==> (32901120/0.1%)
1855 54 ==> (147168/8.4%): [ ] 250001 (1.7) 8080s
1067 62 ==> (  2304/10.1%): [+] 1259 (0.5) 65s
1607 53 ==> (2022720/4.0%): [ ] 250001 (0.1) 6706s
1687 46 ==> (   200/9.8%): [+] 155 (0.8) 5s
 353 68 ==> (2331648/8.8%): [ ] 250001 (0.1) 8447s
2417 46 ==> (  1400/4.7%): [ ] 250001 (178.6) 6714s
2231 51 ==> (    70/30.2%): [+] 1249 (17.8) 57s
1518 51 ==> (   162/16.3%): [+] 3836 (23.7) 164s
1073 47 ==> ( 28152/19.0%): [+] 59173 (2.1) 2447s
1916 59 ==> (   500/15.0%): [+] 194 (0.4) 7s

        // Starts at 5.0, goes towards 3.0, but abrubtly stops at 4.0:
        let len_bonus = f32::max(3.0, ((100.0 - chars_i) / 100.0) * 2.0 + 2.0);

        // 5.0 is just made-up, though.
        prod = f32::powf((1.0 + len_bonus) / filter_ratio, 0.25) as f64 * prod;


Oops, that was the wrong quantization. Mixed bag of a difference, though...